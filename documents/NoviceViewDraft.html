<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 3.1  (Unix)">
	<META NAME="AUTHOR" CONTENT="David Harris">
	<META NAME="CREATED" CONTENT="20100613;17155500">
	<META NAME="CHANGEDBY" CONTENT="David Harris">
	<META NAME="CHANGED" CONTENT="20100621;22052900">
</HEAD>
<BODY LANG="en-CA" DIR="LTR">
<P STYLE="font-style: normal"><FONT SIZE=5><U><B>OpenLCB for Dummies</B></U></FONT></P>
<P><FONT SIZE=4>On first blush, model railroads appear to be only
about running a train around a track. People then focus on how the
train is controlled: is it 'DC', where the the trains are controlled
by the voltage on the track; or is it 'DCC' (Digital Command
Control), where they are controlled by commands sent through the
rails to the engine. The next focus is often the scenery and points
of static interest on the layout, such as lakes and buildings. </FONT>
</P>
<P><FONT SIZE=4>However, even on small layouts, the layout designer
will soon want to add some interesting active accessories, such as
lighting, powered turnouts (points), crossing gates, sound, and
automation. This is where OpenLCB comes in. OpenLCB is a set of
components that are designed to let you control your model railroad
accessories in a simple manner, but is powerful enough to control
very large layouts, such as those in museums or built by modular
clubs. </FONT>
</P>
<P><FONT SIZE=4>OpenLCB compliant equipment is designed to connect
together using a bundle of wire that lets the equipment 'talk' by
sending messages between themselves. Each piece of equipment is
called a 'node', and the connecting wires are called a 'bus' that
acts like a 'party-line'. </FONT>
</P>
<P><FONT SIZE=4>OpenLCB is a 'Local Control Bus' that is developed as
an open-source standard. That is, there are no fees for using the
design, but it is standardized so that products from different
companies will work together, even though they may superficially
operate differently. </FONT>
</P>
<P><FONT SIZE=4>Simple layouts will only have a few nodes, for
example to control turnouts (points) on the layout. In this case, you
would buy one or more turnout-controller nodes and a panel node, such
as a multi-button node, and a power supply. Usually for small layouts
you only have to power one of the nodes, as the others will get their
power from the bus wires. </FONT>
</P>
<P><FONT SIZE=4><U>Making things happen</U>:</FONT></P>
<P><FONT SIZE=4>After you have connected the nodes together as per
their instructions, the nodes all listen on the bus. When something
happens on the layout, such as you pushing a button, the button-node
will send a message on the bus that indicated that the button was
pushed. Other nodes can be taught to respond to that message by
causing something to happen, such as turning on a light, changing a
signal, or moving a turnout. </FONT>
</P>
<P><FONT SIZE=4>Teaching a node to respond differs depending on the
node, but the usual process is to select a number of nodes to listen
and also what action they should take when the message is received,
such as moving a turnout to a specific direction. Then another node
is selected to teach these nodes when a 'trigger' occurs, in this
case when as button is pushed. After the teaching, whenever the
trigger occurs, the button is pushed, then trigger -node sends a
message along the bus to the listening-nodes, which cause their
actions to happen, the turnout is moved. This whole package of
trigger and actions is called an event. </FONT>
</P>
<P><FONT SIZE=4><U>Terminology</U>:</FONT></P>
<P><FONT SIZE=4>This process has its own terminology. The whole
package of triggers, messages, and actions is called the
'Producer/Consumer Model'. The actual message is called an 'event'.
The triggering-node is called a 'producer', because it produces the
event, and the action-node is call the 'consumer', because it
consumes the event. </FONT>
</P>
<P><FONT SIZE=4>The Producer/Consumer, or P/C, Model is very
powerful. It allows one or more producers to cause zero or more
consumers to cause actions. However, its real power comes form the
fact that neither the producers, no the consumers, need to know about
any of the others. While it is obvious that a button press might
cause a turnout to go to the closed position, a single event might
allow two buttons at opposite ends of teh layout to control
twenty-five turnouts to set a route. Events can represent such
abstract concepts as “Set the lighting to dawn”, or “Set the
layout to mainline running”, which can effect multiple different
equipment on the layout. </FONT>
</P>
<P><FONT SIZE=4><U>Connecting to your other equipment</U>:</FONT></P>
<P><FONT SIZE=4>However, at any point, you may want to take advantage
of some of the other features that OpenLCB offers. OpenLCB is the
ability to connect legacy model railroad equipment that you may own,
for example, you can connect to DCC, Loconet, Xpressnet, C\MRI, etc.
These nodes are called 'bridges' and come in a variety of flavours,
depending on what you need. </FONT>
</P>
<P><FONT SIZE=4><U>Bridging</U>:</FONT></P>
<P><FONT SIZE=4>While OpenLCB is simple to operate and to teach
events to, it really shines as your layout grows. All things have
limits and eventually you will have more nodes than a single bus can
contain. This will be anywhere from 25-75 nodes. At that point, you
can simply divide you bus into two bus-segments, and join them with a
bus-repeater. The problem is that any bus segment will be limited by
getting too long, having too many nodes, too much activity, or
needing too much power. By dividing the bus in two you make two
segments that are shorter, have less nodes, and need less power. The
bus-repeater node simply joins the two halves together. The important
point is that you do not have to change anything else. All your
programming is intact and you can just continue as you were. </FONT>
</P>
<P><FONT SIZE=4>A bus-repeater is a simple 'bridge' node, it just
sends all the activity on one segment to the other. You may have
noticed above that dividing your bus into two segments did not reduce
the bus activity. Fancier bridges are available that can not only
connect segments together but can reduce the activity on each of them
to only those messages that are useful to each segment. </FONT>
</P>
<P><FONT SIZE=4>One such bridge connects the bus to Ethernet – this
actually runs the OpenLCB protocol on ethernet, allowing you not only
to connect your computer, but also connect your layout to the wider
world and the internet. Ethernet is most useful to larger layouts
because it lets them join many bus-segments together, and,  since
Ethernet has a higher 'bandwidth', it can easily handle the activity
of those segments. </FONT>
</P>
<P><FONT SIZE=4><U>No need to know Node-IDs</U>:</FONT></P>
<P><FONT SIZE=4>One of the biggest advantage of OpenLCB is not
apparent unless you compare it to other buses. Other buses require
the user to choose 'node IDs' and to ensure that no node has the same
ID. This is quite easy on small layouts, reasonable of\n larger
layouts, but becomes almost impossible on very large layouts or
layouts that are put together in an ad hoc manner, such as occurs at
large meets of modular groups, such as Fremo, Free-mo, Ntrak,
oNeTrak, etc. OpenLCB makes putting together these layouts reasonably
painless and efficient. Together with other advanced features,
OpenLCB lets these groups focus on enjoying their massive layouts. </FONT>
</P>
</BODY>
</HTML>