   PowerPlusWaterMarkObject1

                                                             OpenLCB Technical Note

                                                            Broadcast Time Protocol

                                                   Feb 23, 2019                           Draft             

                                                1 Introduction

   Model railroad layouts sometime have their own time displayed via visible clocks that people refer to
   when operating the layout. These might display a different time of day from the current real clockworld
   time, so that an evening train can be run during the day. TheyModel railroad clocks might run at a
   different rate than real time (e.g., faster), so that the shorter distances of the model are covered by
   a train in the right number of “fast minutes”.

   Layouts that have multiple clock faces might want to synchronize them by running them from a single time
   generator. OpenLCB should provide a way to do that over the existing OpenLCB infrastructure.

   Producer/Consumer events, one per second or minute, could certainly meet this need. Since event IDs are
   arbitrary, in the absence of any other support, the clocks would have to have 24*60 or 24*60*60 separate
   event IDs configured between clock time producers and consumers. This is untenable. Hence, the primary
   reason for this Standard is to create well-defined ranges of event IDs with specific meanings that can
   be used to represent time for driving clock displays.

   A secondary purpose is to allow producers on the layout to control the clock operation, such as starting
   and stopping the clock, or setting the rate or current time by producing certain events.

   A tertiary purpose is to allow other consumers on the layout to be controlled via the time signal by
   interpreting the events or event ranges specified here. Not all timing-related purposes will be met by
   the contents of this Standard, and other ways of handling timing information maywill be needed for
   thosedefined in the future.

1.1 Served use cases

   Fast clocks distributed around the layout all show the fast time. They start and stop together. Start
   and stop controls are distributed around the layout. The rate can be varied as needed. The display
   includes a modeled date.

   In addition to fast time, a “correct wall-clock time” can also be distributed around the layout room.
   Further, a “duration so far” time iscan be distributed around the layout. It starts and stops
   independently of the fast clock.

   A node connected to drive lights in modeled buildings lights turns them on and off at specific
   fast-clock times. A control for lights or ventilation can turn it on and off at specific wall-clock
   times. A node controlling a speaker can play a church bell sound at 12 noon (based on either model or
   real world time).

   Time acts in multiple ways:

     * Action at a specific time: “The bell rings at noon”

     * Condition during an interval: “The porch light should be on from 5PM to midnight”

     * As a state: “The clock shows 10:15AM”

   Model building lights and layout room lights turn on and off in a fast cycle to simulate a day every 10
   minutes.

   The model railroad can run through a scenario: Start at 17:00 (5PM) and run to 20:00 (8PM), then go back
   to 17:00 and repeat.

   A town contains 100 separate lights, each connected to an output pin on OpenLCB nodes. They turn on and
   off on a detailed cycle.

   Simple nodes should be able to respond to timed events without any additional cost. A simple input node
   can be configured to control a fast clock with a few common configuration-defined settings, such as
   buttons or a toggle switch to stop and start the clock, a few buttons to select a rate, and a button to
   set time to 8:00am. The clock running/stopped state can be displayed with a LED on a simple node.

   Modular layout sections developed and configured in separate locations can be brought together and
   operated without prior management/allocation of magic numbers, and with only minimal (at most one node
   and one operation) reconfiguration.

1.2 Unserved use cases

   This Standard does not completely solve the use cases in this section.

   The model building lights turn on and off only a few seconds apart - : this proposal is for
   minute-granularity timing. Faster timing can be controlled from the node using a script that gets its
   initial trigger from the fast clock signal, or some other node can produce closely-timed events that are
   consumed to drive the lights.

   Rapidly moving from one time to another, e.g from 20:00 back to 17:00 in the use case above, can be done
   in several ways, none of which cover all needs:

     * By rapidly stepping through the intervening minutes. This will ensure that e.g. a light that turns
       on at 14:00 and off at 18:00 will properly be on when the sequence restarts at 17:00. But it will
       also cause the church bell that's scheduled to strike at 08:00 and 12:00 to ring twice between
       “20:00” and “17:00”.

     * By going directly to 17:00. This will skip ringing the church bells in the point above, but might
       not get the state at 17:00 correct. The state can be addressed by optionally producing the necessary
       events as part of going directly., but it's not possible to automatically determine which events are
       consumed for state changes (light on), and which for instantaneous occurrences (toll bell).

   Layout lights execute a pattern that's different when the modeled day is Monday vs Saturday – : Day of
   week, or calendar date in general, does not result in different events being produced.

   Both of Thisthese use cases should be solved using the regular producer-consumer techniques and a
   smarter scheduler to produce the appropriate events.

                                        2 Annotations to the Standard

2.1 Introduction

   Note that this section of the Standard is informative, not normative.

   Clock events are produced by a clock generator, and consumed by clock faces and other devices that want
   information about time. The events themselves are called “clock events”, as they carry information about
   the current clock time.

2.2 Intended Use

   Note that this section of the Standard is informative, not normative.

2.3 Reference and Context

   This specification is in the context of the following OpenLCB-CAN Standards:

     * OpenLCB Event Transport Standard, which defines messages for transporting Event IDs and identifying
       producers and consumers.

     * The OpenLCB Event Identifiers Standard, which defines the format and content of Event IDs including
       the class of Well-Known Event IDs and Automatically-Routed Event IDs.

     * OpenLCB Unique Identifiers Standard, which defines the allocation of OpenLCB 48-bit unique
       identifiers

   For more information on format and presentation, see:

     * OpenLCB Common Information Technical Note

2.4 Message Formats

   The “Specific Uupper Pparts” can be separated into well-known “public” Identifiersones, and
   self-allocated “private” Identifiersones. Much of the first part of this section is to ensure that the
   self-allocated upper parts result in unique event IDs that cannot inadvertently collide.

   The “Default Fast Clock”, “Default Real-Time Clock”, “Alternate Clock 1”, and “Alternate Clock 2” terms
   are not further defined in the Standard. They have no operational effect. They're provided to make it
   easier for a clock face manufacturer to set up the clock face node to automatically find the default
   fast clock generator, without user involvement, when attached to an OpenLCB installation. OneA single
   fast clock system is expected to be the most common installation, and this makes it very convenient for
   the user.

   The values are packed into two bytes to make it easier to allocate the unique “Specific Upper Part” by
   using an OpenLCB uUnique IDIdentifier.

   While the terms “Fast Clock” and “Real-Time Clock” are not intentionally undefined, one valid, and
   likely common, interpretation of these terms may be as follows.

     * Fast Clock – A clock that runs at some ratio, typically faster, to real world time.

     * Real-Time Clock – A clock that runs at a 1:1 ratio to real world time.

  2.4.1 Set/Report Time Event ID

   While time is always represented in 24-hour form (00:00 is midnight) in the transmitted messages and
   clock state, this is independent to how time is displayed to the user. For products that have a clock
   display, it is up to the manufacturer to decide whether to use 12-hour or 24-hour time display, or
   provide a user-controllable setting for this. There is no provision in this Standard for centrally
   establishing formatting settings; manufacturer could provide configuration via physical buttons or the
   established configuration standards like the Memory Configuration Protocol and Configuration Description
   Information standards.

  2.4.2 Set/Report Date Event ID

   These two event types are structured in bytes for ease of programming. It is not a goal for a
   hexadecimal dump of the packet be human-readable (hence not using BCD encoding).

  2.4.3 Set/Report Year Event ID

   (It's been proposed that the year instead be in some BCD format, which represents 999 years around some
   epoch)

   The range chosen, 0 AD to 4095 AD, is chosen to be sufficiently inclusive of the whole relevant span of
   railroad history typically represented in model form both in the past and for the foreseeable future.

  2.4.4 Set/Report Rate Event ID

   A rate of zero is valid. The stop/start clock event should be used to stop and start the clock, because
   that doesn't require resetting, or even knowing, the current rate. A rate of zero means the clock is
   stopped, though it is preferred to use the Stop/Start Events for starting and stopping the clock.

   Negative rates mean the modeled time is moving backwards. Negative rates are represented using standard
   signed integer formats (i.e., 2’s complement notation), for example 0x4800 is -512.00, 0x4801 is
   -511.75, … 0x4FFE is -0.5, and 0x4FFF is -0.25. The rate is intended to be a ration measured against
   real world time.

  2.4.5 Set Time Event ID

   These event IDs are exactly 0x8000 shifted from the matching Report event IDs for ease of programming.

  2.4.6 Set Date Event ID

   These event IDs are exactly 0x8000 shifted from the matching Report event IDs for ease of programming.

  2.4.7 Set Year Event ID

   These event IDs are exactly 0x8000 shifted from the matching Report event IDs for ease of programming.

  2.4.8 Set Rate Event ID.

   These event IDs are exactly 0x8000 shifted from the matching Report event IDs for ease of programming.

  2.4.9 Query Event ID

   This event ID will cause the clock generator to report it’s entire internal state.

  2.4.10 Stop/Start ClockEvent ID

   Having a separate start/stop mechanism, instead of just setting rate to zero, makes distributed
   start/stop control easier. There'’s no need for everybody to remember the current rate while the clock
   is stopped.

  2.4.11 Date Rollover Event ID

   This event ID works around race conditions involving changes in date and time due to midnight rollover.

  2.4.12 Undefined/Reserved Event ID’s

   Any Event ID’s not explicitly defined by the standard are reserved for future use.

2.5 States

   The “independent” in the definition of states means that clock generators work independently of each
   other, and don't have linked states.

   It's up to the node implementor to decide how to implement the internal clock time. It could be an
   internal time generator of some kind, or linked to some external time reference.

2.6 Interactions Nodes that receive an event ID that would set the rate, date or year, but do not actually set
to the specific value, send an event ID with the value they do set. There may be other consumers listening and
tracking the state of the clock, and producing these event IDs keeps all those in synch.

   Nodes that want the date, e.g. to initialize a display, can ask for the Set/ReportDate event status from
   the clock-producer node using IdentifyEvents.

   A simple implementation can just produce them always.The Set/Report Rate interaction is written in a way
   that makes options available for e.g. low-bandwidth clocks, see below.The reply to an enquiry about
   “Delivers Clock Protocol” depends on whether the clock generator is operating, not running. It's
   operating if it's serving as a clock generator and will produce and consume the appropriate event IDs.
   This is provided to allow a clock generator to be placed on or removed from an operating layout.

   Status events are not produced while the clock is not running so that it's possible to stop all traffic
   on the network.

2.7

   Note that nodes should not assume that they will receive any time event only once. As time is set, it'’s
   possible for a node to receive the current time more than once.

   Note that the time is only advertised with minute granularity. If a Set Time is received when the
   current clock is 20 seconds pasrt the minute, setting the time will set the time to exactly the minute
   received, with nozero as seconds partvalue taken into account.

   It is not expected that it will be routine for clock generators to refuse to set their time, nor that
   other nodes will attempt to set it when not allowed to. If the clock generator node does not change the
   time the time upon receipt of a Set Time event, it has to produce another Set/Report Time so that all
   listening nodes know the current minute is still as specified by the clock generator, not the Set Time
   request. The Standard is silent as to whether the seconds counter inside the clock should be reset to
   zero at this point. However, it can be implied that a Report Time Event is sent when the seconds count
   is equal to zero, and when an Event Producer Identified Valid message for the Report Time Event is sent,
   the seconds count is not assumed to be equal to zero.

   The complete time, year-date-time, is sent in several events. The Standard does not specify what order
   these are sent in at midnight or the start of January 1^st, only that the updates be sent. Nodes that
   are using year and date information to do computations should use their own internal state(s) to track
   the transition from one day to the next.results in the time changing, that's a time change that has to
   result in a Time Report event being produced. Some methods of computing fast time can produce
   discontinuous changes in time when the rate changes, while others do not. If a rate change

   In general, fast clocks don't always have 60 seconds to the minute in any case, and the next routine
   time announcement will be at a zero-seconds count, so neither of these is a critical issue and both are
   allowed. It's recommended that clocks set when they receive a Set Time event, and that nodes not send
   one unless the network has been configured to allow it.

     * Not resetting it allows time to move continuously. Nodes have to understand that the time they
       receive is just to the nearest minute, and not infer that the seconds value associated with a Report
       Time event will always be zero.

   Resetting it allows other nodes to assume that the seconds value associated with a Report Time event is
   always zero, at the cost of preventing time from being exactly 60 seconds to a minute always.

   OpenLCB doesn'’t have latency guarantees, so different nodes may have slightly different ideas of the
   time. In practice, the differences should be much less than a second for operating OpenLCB
   installations. It is allowable, though not required, for a clock consumer to perform an average on any
   observed jitter of of the incoming Report Time Events such that it can factor out that jitter on the
   node’s internal tracking of the passage of time. The exact algorithm is not prescribed.

   Clock generators may also set their time in respondse to other events to set their time, not specified
   here. For example, to allow slaving of a clock generators’s events to time events from another clock
   generator, a clock generator may react to time event IDs with another high six bytes Specific Upper
   Part. How, when, whether to do that is an internal configuration option of the clock generator node, and
   is not discussed by the Standard.

   It is also permissible for a clock generator to have other mechanisms of setting its configuration
   including the current time or rate; one example would be pushbuttons on the generator node; another to
   have a consumed event for re-setting to the start of an operating session with configuration-determined
   values (e.g. 6:00am on October 3, 1953, rate 2.5x).

  2.7.1 Startup

   As stated in section 1.1 above, there are use cases, such as a clock face display, where a node will be
   consuming either all or the vast majority of clock events. In this case, it is preferable to use the
   Consumer Range Identified message in order to announce consumption of clock events.

   There is another use case where a node may only be consuming a single or few clock events. In this case,
   it is preferable to use the Consumer Identified message to announce consumption of clock events. Some
   clock event consumers do not know anything about the concept of time, or make any distinction between
   clock events and other event non-clock events. From their point of view, they are generic event
   consumers.

   The distinction of these two sets of messages can (and shall) be used to filter messages that need to be
   sent to the bus vs those that can be suppressed.

  2.7.2 Clock Report

   The reason to limit the Report Time Event generation to once per real world minute is not only motivated
   by conserving bandwidth. ThoughEven the with no filtering the fastedst clock rate of 511.75511.75:1
   would would result well over 50% of the total bandwidth availablein about 1% of the bandwidth of to a
   CAN bus segment being used up., if we consider a more practically realistic clock rate of 12:1, the
   resulting bandwidth used becomes less than 3% . Rather, the motivation behind limiting the Report Time
   Event generation is to prevent adding too much clutter in bus capture logs. The desirable property is
   that a layout bus should have no messages passing by in quiescent state.One Report Time Event sent once
   per real minute results in a total CAN bus bandwidth utilization of less than 0.5%.

   It is important to note that, unless following one of the noted exceptions, a clock generator is not
   required to produce any clocktime events for which a specific clock event consumer has not been
   identified – a consumer specifying the entire event range does not count here.

   The process for a clock generator to identify all the clock event consumers is not explicitly specified.
   Two possible options include:

    1. Send an Identify Events Addressed message to each node in the network as described in section 3.10
       below.

    2. Send an Identify Events Global message.

   Clock consumers that display the time are required, in the absence of all event IDs being produced, to
   keep track of time internally. It is recommended that a clock display have an internal clock of
   sufficient accuracy to correctly extrapolate fast time into at least one real world hour without
   divergence between different units visible on the display. A common crystal oscillator has much better
   accuracy than this requirement.

   A separate Date Rollover Event is required so that a clock consumer which tracks and progresses time
   internally can distinguish between a Report Time Event as a request to set the clock back in time within
   the same day versus a progression in time into the next day. The reasoning behind the three second delay
   for producing the Report Year and Report Date events is such that network delays do not result in smart
   clock consumers becoming confused about what the actual year and date is when their internal
   implementation of time rolls over asynchronous to clock Report Time Events.

  2.7.3 Clock Synchronization

   The requirement to always produce the next minute event is added so that clock consumers can learn the
   second counter of the clock producer and synchronize to each other. catch any duplicate clock query
   commands and respond with a single announcement to all of them.query is seen;

   clock producers may delay the reply to the clock query by a few hundred milliseconds in order toten to
   each others’ requests for clock query and suppress their own query when another

   This interaction can be used by a clock consumer to inquire time at it’s startup in case it has missed
   the announcements of the clock producer, or during running when it is uncertain about its internal
   clock’s accuracy because it hasn’t seen a time report for a long while. It is desirable however, that
   layouts with many clock consumers to be able to start up and operate without each of them individually
   requesting and receiving clock updates. Instead,

   clock consumers should lis

  2.7.4 Clock Query

   When a clock consumer wants to know the current time, it may also want to know the Start or Stop state,
   Rate, Year, Date, and Time. The sequence prescribed allows all of this information to be provided in a
   short burst sequence.

   This interaction can be used by a clock consumer to inquire time at it’s startup in case it has missed
   the announcements of the clock producer, or during running when it is uncertain about its internal
   clock’s accuracy because it hasn’t seen a time report for a long while. It is desirable however, that
   layouts with many clock consumers to be able to start up and operate without each of them individually
   requesting and receiving clock updates. Instead,

    1. clock consumers should listen to each others’ requests for clock query and suppress their own query
       when another query is seen;

    2. clock producers may delay the reply to the clock query by a few hundred milliseconds in order to
       catch any duplicate clock query commands and respond with a single announcement to all of them.

  2.7.5 Clock Set

   The Start or Stop state, Rate, Year, Date, or Time may each be set independently. If the desire is to
   change more than one of these settings at one time, it is recommended, though not required, to first
   stop the clock, then request the Rate, Year, Date, and/or Time settings, and finally (if desired) start
   the clock.

   A race condition is possible between two nodes simultaneously requesting to adjust the Rate, Year, Date,
   and/or Time of a clock. While it is unpredictable (and possibly diverging) in which order the individual
   nodes of the layout will see the Set events, the clock generator is required to echo the effective value
   after setting; these echoed messages, even if multiple of them are sent in a short period of time, will
   always be received in the same order by all nodes on the bus. Any possible remaining ordering problem
   (e.g. on Start/Stop events) will be fixed to convergence three seconds later when the current state is
   announced.

   Clock events from clock generators with other Specific Upper Part values must be identified by another
   means, see “Further Work” section below.s, along with IdentifyProducedEvent messages for all other
   producers on the node.

   Clock events from the four well-known clocks can be identified by the well-known six-byte Specific Upper
   Part of the event ID. s.To find the current clock:

     * Send a global IdentifyProducers for well-known event ID “Delivers Clock Protocol”

     * If there's no reply, no clock exists. If there is a reply, extract the source node ID (alias) of the
       clock producer node and send an IdentifyEvents.

   The reply will contain IdentifyProducedEvent messages that show the current clock producer state via
   their active/valid statu

   devices rapidly establish information about a clock, even if they don't know it exists. s letevent
   transfer protocol combines with these event definition toThe ThisEvent Identification and Reporting

   It is not required that a clock generator support the setting of its time through events. A clock
   generator may, for example, only accept the setting of its time through a local push button interface,
   or by using the memory configuration protocol. This would fall under the category of an “out of band”
   mechanism.

                                           3 Background Information

   Perhaps it should be added to the PIP mechanism to make it unambiguous that the node manufacturer
   intends this to be supported, trigger automated tests, etc., because it's totally self-identifying.
   There's no formal, functional need to check for it. IdentifyProducers can find the clock producer
   node(s) on the layout. otocol Identification messagethe PrPIPThis protocol doesn't appear in This
   section will go directly into the Technical Note.

   This section is general information of interest to the reader, implementers, etc...

3.1 Multiple Clocks

   A user might want multiple clocks, for example a real-time clock display to show current time, and a
   fast clock display to show railroad time.

   The protocol provides for this via multiple clock generators with unique Node IDsupper parts in their
   event IDs, but it'’s up to the user to allocate clock generators and configure the clock producers and
   consumers to use the proper clock number as part of their event range.

   Multiple clock generators using the same event ID range will not function properly. The source node IDs
   in the Producer-Consumer Event Report messages produced by the multiple clocks can help diagnose and
   correct this.

3.2 Time Zones

   The standard is purposely silent on the topic of time zones. It is up to the user to determine if and
   how time zones are represented. There are two options that are proposed here, and other solutions may
   also be possible.

    1. The clock generator sends out time representing one coordinated universal time (UTC). Each time
       consumer is then programmed to add or subtract an offset of the universal time appropriate to their
       specific location. This is similar to how modern computer systems get and display their local time.

    2. Create a separate clock generator for each local time to be represented. One of the clock generators
       is designated the “master” to which all the other clock generators synchronize to, adding or
       subtracting their “local” offset appropriately. Section 3.11 below has more information about how
       this can be achieved. A special case of this option is when only one time zone is in effect for the
       entire railroad: the clock generator may be set to railroad local time and no time offset needs to
       be configured on the clock listeners / displays. This will be the majority use-case.

3.3 Daylight Savings Time

   The standard is purposely silent on topic of daylight savings time. This is in part because of the hyper
   locality specific nature of Daylight Savings Time. This is not something that is easily predictable by
   simple machines and can even change based on local legislation. It is possible for a time consumer
   implementation to provide a means for the user to enable/disable Daylight Savings Time and adjust what
   is displayed accordingly.

3.4 Day of the Week

   There are a number of use cases where a day of the week may be relevant.

    1. Church bells that have a special ring schedule for Sundays.

    2. Commercial buildings that may not turn on as many lights on a weekend.

    3. Display the day of the week on a clock face in order to indicate the time table being used in a
       given operating session.

   There are no events defined to represent the day of the week. A time consumer can use standard language
   library API’s in order to convert a date to day of the week. These libraries exist for most modern
   programming languages (C/C++, C#, Objective-C, Java, Python, etc…).

   Simple nodes will need to use facilities from a time cue-node to schedule events being produced at
   certain days only. Day-of-week events would not help simple nodes to achieve use-cases 1. and 2. above,
   since those would require a complex logic operations on the day-of-week and time events, including
   keeping track of a 7-way state machine and intersecting its state to the time events. A 7-way state
   machine exceeds the capabilities of currently available simple nodes. A much more robust solution is to
   use a pair of events output from a time cue-node (see Section 3.9) for covering precisely the desired
   time interval, which could be “Sunday 10am” vs “everything else” for case 1; “Friday 10pm – Saturday
   5am” and “Saturday 10pm – Sunday 5am” for case 2; and “Wednesday” vs “not Wednesday” for one light
   output of case 3. This solution can easily be made compatible with time jumps.

3.5 Jumps in Time

   Through configuration, it is possible that a clock generator would make a large jump, forward or
   backward, in time from its previous set time. The only requirement about this jump is that the sequence
   described in section matching 2.6.5 above follows the jump.

   It is allowable, though not required, for a a clock generator to produce intermediate Report Time
   Events, as well as Report Year and Date events, at a highly accelerated rate. One possible use case for
   this is to “reset” time for nodes that consume clock events but otherwise have no knowledge of the
   concept of time. If either of these, or similar, techniques are deployed, the sequenced described in
   section 2.6.5 above is still required once the application of the technique is complete and the new set
   time is reached.

   It is not prescribed how this might occur, but one can imagine a number of different scenarios:

    1. Generic event consumers are setup to turn on/off lights at certain time throughout a simulated day.
       The end of an operating session occurs asynchronous to a full cycle. The operator wants to reset
       time to the beginning of the day for the next session. In order to reset the interactions, the clock
       generator replays the new set time’s previous 24-hours in the form of events before settling on the
       new time.

    2. A jump forward in time occurs. In order for generic event consumers to progress their state to this
       new time, intermediate clock events are sent at an accelerated rate until the new set time is
       reached.

    3. Generic event consumers are taught to consume one additional event, the “start of operating session”
       event, re-setting their state to the desired state at that point. This does not allow arbitrary
       jumps however.

3.6 Date Rollover

   In some cases it may not be desirable to have a clock generator rollover at the end of a day into the
   next day, but rather start all over at the beginning of the current day. This would prevent the
   progression of the date, but allow the continuous 24 hour cycle of time. The standard is quiete on this
   use case, but it is certainly a possible implementation option in a clock generator.

3.7 Configuration via a sSimple tTeach-lLearn UIser Interface

   Blue and Gold configuration does not have to be implemented, perhaps many devices won'’t, but important
   to show it can be done. Configuring consumers to react to a particular time event can be done by putting
   a programming button on the master time producer that sends the learn message for the current clock
   time.

   For Example:Better (more powerful) UIs can then use the same underlying teach/learn implementation.

   To Teach: gold; blue to select: hour, +minute,; rate; up/down to change; gold

   To nominate: blue, blue; gold to select: h,+m,r; up/down; blueFrom the Arduino docs:

   The User Interface (UI) uses the Blue / Gold buttons:

   A (Blue/Gold)+ sequence Sets or Nominates the Time, Rate or Alarms to learn a Teach-event.

   Gold(Blue/Gold)+ sequence sends a Teach-event which includes the event associated with the current-Time,
   the Rate-, or any of the Alarms.

   Better (more powerful) user interfaces can then use the same underlying teach/learn implementation.

3.8 Alarms

   Early OpenLCB clock prototypes contained support for “Alarms”, special events that could be configured
   to be produced at a specific time. By configuring consumers to listen for the alarm event, instead of a
   particular time, it becomes easier to reconfigure the start or stop time for layout activities: Change
   one thing, the association between producing the alarm event and the time that it happens, and all the
   other nodes will follow without reconfiguration. This method is also sometimes called “cueing”.

   This protocol does not contain any specific support for alarms or cueing, because it doesn't need to.
   Simplicity is important, and the production of alarms can proceed completely independently. Any event ID
   could be produced by any node, upon receipt of the particular time event, and thatthe details of that
   don'tes not have to be part of this protocol. An alarm-producer isn't specifically part of the clock
   producer. It could be anywherealso shipped with a clock consumer or a generic consumer configured to a
   specific time event. And no protocol needs to be defined for alarm events, as they're just regular
   produced events: When event A is producedconsumed, produce B and C. That's a generally-useful thing to
   have, even for non-time events.

3.9 Time-range cues

   A not-well-served case of the Standard is the operation of simple consumer nodes for turning on their
   outputs for desired periods of time, e.g. a street light to turn on during night time. Learning the
   direct event ID of the time when night should start and stop works in simple progression, but requires
   workarounds presented in section 1.2 and 3.5 to support jumps in time.

   A way to correctly support jumps in time is by an advanced clock cue node. This cue node keeps track of
   the time internally by being a clock consumer. By configuration (e.g. via the CDI) it knows which time
   range the user is interested in; automatically produces the on and off events when the time passes these
   boundaries, and specifically produces an on or off event in case it detects a jump.

   Such a clock cue node could also be shipped optionally as an added feature of a clock generator.

3.10 Low-Bandwidth Clock Producers

   The Standard specifies that only time events with consumers need to be produced. Clock-producing nodes
   can use this to reduce the bandwidth used by the clock events, particularly at high rate. The producing
   node can automatically generate and maintain a list of consumed event IDs, and produce only those.

   Once the clock-producing node is up and running, it can listen for Consumer Identified and Consumer
   Range Identified messages and include any Set/Report Time Eevent IDs seen in its list. Nodes that newly
   attach or restart will emit these automatically. So long as the clock-producing node isn't marked as a
   Simple node, these will be forwarded to it.

   The process to find all consumers when the clock-producing node becomes active on an already existing
   OpenLCB network is similar, it just involves querying the entire network:

     * Send a Verify Node Global, and construct a list of nodes from the response

     * At a suitably metered interval, send an Identify Event Addressed to each node.

     * Construct the list of consumed event IDs from the response.

   There is currently no support to do a network-parallel query such as “Identify All Consumers of Event
   IDs in the following Range” due to buffer-management and network-load-scaling issues with it.

3.11 Slaving Clock Generators

   For some modular layout use cases (still being identified), it's useful to have the time events be
   created in synchronous with some other a local modular clock generator. For example, a modular segment
   has a clock generator and multiple nodes that are configured to together do complex automation. You want
   to include it in a larger modular layout without having to reconfigure this.

   One way to do that is to slave the modular clock generator to another master clock generator, so that
   the master clock generator controls and specifies the time, and the modular clock generator produces its
   own events to represent that time. The consuming nodes then act on the modular clock events they are
   configured with.

   Operationally, this slaving consists of reissuing the events with a different top-end bytes“Specific
   Upper Part”, translating the top-end bytes“Specific Upper Part” from the master clock generator's values
   to the slaved modular clock generator's values.

   Mechanically, this can be done by having a mode in the clock generator node that does this, having a
   gateway onto the modular OpenLCB segment that does the translation (and removing the original modular
   clock generator), using a node that can do alarms/cueing for the needed events, or some other mechanism.
   The standard is about protocol, not implementation, and so is silent about this.

   If a modular clock generator is to be configured to follow some other clock event range, that raises the
   question of how to do it. The Standard is silent about this too, but it's important that there be a way
   to do it within the Standard. Choices include:

     * Configure it via the memory configuration protocol to listen for a particular value of the top
       bytes.

     * Many layouts just have one clock generator. If that's true, a button on the clock that says “Slave
       to master” will get the right one. If there's more than one, pushing that button could just go to
       the next one.

     * Use teach/learn or blue/gold to teach an event from the master clock, or some producer or consumer
       of the master clock, to the slave. For example, if there's a master “clock stop” button, teach that
       to the slave so that it knows that's the range to listen to. This can be done even if there are
       multiple clocks operating on the layout.

3.12 History and Numerology

   There are slightly more than 2^16 seconds in a day, and just less than 2^11 minutes. A 17-bit “seconds
   since midnight” format could be used, but it would still take three bytes, and is somewhat harder to
   read and display. It would keep the non-used code points together, perhaps better for expansion, but
   it's not clear how much time is going to expand.

   By-seconds events allow much more precise timing, particularly at low fast-clock multipliers (clocks
   near real-time), but they result in too much traffic at high fast-clock multipliers (really fast
   clocks). A 10 minute fast 24 hour cycle is 144 messages per second, more than 15% of CAN bandwidth. Even
   faster rates, for example to do a fast recycle to prepare for a new sequence, would clearly saturate the
   bus. Sparse clocks would help with this, but are significantly more complex for the clock generator,
   which may need a lot of event storage to keep rates low. This has led to the choice of minute events,
   with seconds reserved for possible future consideration.

   A denser format would be 5 bits hour, 6 bits minutes, 6 bits seconds all put consecutively, instead of
   in separate bytes. That still takes three bytes, but keeps the seven spare bits together.

   Commands to change the run/stop state and clock rate are broadcast as separate events. That's better
   than coding them in the time events themselves, because if e.g. rate was separate bits in the event,
   simple nodes could not be configured to recognize specific times. of the day.We're not sending
   events-with-only-minutes, or -only-seconds. Those make it easy to do something once a minute or once a
   second via consumer, but those are not to the only interesting intervals: Just do the calculation.

   Regardless of whether the clock sends seconds or minutes, small times can be maintained via a local
   timebase synchronized to the time broadcast and the rate messages. There's a limit to how precise this
   can be, but it is probably worth a factor of 10 and perhaps 100 in resolution.

   Using received time is much simpler, and the smallest time commonly used by fast clocks is the second.
   Since OpenLCB networks can handle 3-4 messages/second for a fast clock with second resolution, it seems
   simplest to just broadcast the seconds. The choice of filtering as a requirement to the clock producer
   came from the wish to keep the bus quiescent for monitoring/logging/debugging purposes when there is no
   human interaction with the layout.

                                                4 Future Work

   iguration, or a configuration tool is passing an event ID from the clock generator to the clock. This
   doesn't interfere with operating and configuring clock producers and clock faces manually. In that case,
   the events are known by the person doing the conf to an IdentifyEvents message to the node. But it may
   not be possible to disentangle the clock events from other events produced by the node, particularly if
   the node produces multiple ranges of events. A better solution for this would be useful.ing for
   producers of the “Delivers Clock Protocol” event. The clock events will then appear in the set of
   ProducerIdentified and ProducerRangeIdentified repliesiable solution to finding time event IDs with a
   non-common upper part. A node that produces its own time events can be found by askThere is no
   fully-relPerhaps this should be added to the Protocol Identification mechanism to make it unambiguous
   that the node manufacturer intends this to be supported, trigger automated tests, etc.

   Event identificationThe existence of this Simple Time Protocol does not preclude the existence of other
   protocols for the conveyance of time. It is possible that that future time related protocols could be
   developed in order to realize the unserved use cases identified in section 1.2 above.

   Table of Contents

   1 Introduction 1

   1.1 Served use cases 1

   1.2 Unserved use cases 2

   2 Annotations to the Standard 3

   2.1 Introduction 3

   2.2 Intended Use 3

   2.3 Reference and Context 3

   2.4 Message Formats 3

   2.4.1 Report Time Event ID 4

   2.4.2 Report Date Event ID 4

   2.4.3 Report Year Event ID 4

   2.4.4 Report Rate Event ID 4

   2.4.5 Set Time Event ID 4

   2.4.6 Set Date Event ID 4

   2.4.7 Set Year Event ID 4

   2.4.8 Set Rate Event ID 4

   2.4.9 Query Event ID 4

   2.4.10 Stop/Start Event ID 4

   2.4.11 Date Rollover Event ID 4

   2.4.12 Undefined/Reserved Event ID’s 5

   2.5 States 5

   2.6 Interactions 5

   2.6.1 Startup 5

   2.6.2 Clock Report 6

   2.6.3 Clock Synchronization 6

   2.6.4 Clock Query 6

   2.6.5 Clock Set 7

   3 Background Information 7

   3.1 Multiple Clocks 7

   3.2 Time Zones 7

   3.3 Daylight Savings Time 8

   3.4 Day of the Week 8

   3.5 Jumps in Time 9

   3.6 Date Rollover 9

   3.7 Configuration via a Simple Teach-Learn User Interface 9

   3.8 Alarms 10

   3.9 Time-range cues 10

   3.10 Low-Bandwidth Clock Producers 10

   3.11 Slaving Clock Generators 11

   3.12 History and Numerology 11

   4 Future Work 12

   Copyright 2018-2019. All rights reserved. See http://openlcb.org/Licensing.html for license terms.  Page
   1 of 12 - Feb 23, 2019
